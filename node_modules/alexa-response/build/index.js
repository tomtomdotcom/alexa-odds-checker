'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var ssmlJsx = require('ssml-jsx');
var ssmlJsx__default = _interopDefault(ssmlJsx);
var alexaConstants = require('alexa-constants');

var _class;
var _temp;

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

let Response$1 = (_temp = _class = class Response {

  constructor(state = {}) {
    this.state = state;
  }

  ask(text, type) {
    return this.say(text, type).shouldEndSession(false);
  }

  say(text, type) {
    return new Response(Object.assign({}, this.state, {
      response: Object.assign({}, this.state.response, {
        shouldEndSession: true
      }, outputSpeech(text, type))
    }));
  }

  reprompt(text, type) {
    return new Response(Object.assign({}, this.state, {
      response: Object.assign({}, this.state.response, {
        reprompt: Object.assign({}, outputSpeech(text, type))
      })
    }));
  }

  card(_ref) {
    let { type = alexaConstants.CardType.Simple } = _ref,
        rest = _objectWithoutProperties(_ref, ['type']);

    return new Response(Object.assign({}, this.state, {
      response: Object.assign({}, this.state.response, {
        card: Object.assign({}, rest, type && { type })
      })
    }));
  }

  attributes(data) {
    return new Response(Object.assign({}, this.state, {
      sessionAttributes: Object.assign({}, this.state.sessionAttributes, data)
    }));
  }

  shouldEndSession(shouldEndSession) {
    return new Response(Object.assign({}, this.state, {
      response: Object.assign({}, this.state.response, {
        shouldEndSession
      })
    }));
  }

  directives(directive, ...rest) {
    const directives = Array.isArray(directive) ? directive : [directive, ...rest];
    const { directives: previousDirectives = [] } = this.state.response || {};
    return new Response(Object.assign({}, this.state, {
      response: Object.assign({}, this.state.response, {
        directives: [...previousDirectives, ...directives]
      })
    }));
  }

  build(attributes) {
    return Object.assign({
      version: '1.0'
    }, this.state, {
      response: Object.assign({
        shouldEndSession: true
      }, this.state.response)
    }, attributes || this.state.sessionAttributes ? { sessionAttributes: Object.assign({}, attributes, this.state.sessionAttributes) } : null);
  }
}, _class.ask = (...args) => new Response$1().ask(...args), _class.say = (...args) => new Response$1().say(...args), _class.card = (...args) => new Response$1().card(...args), _class.reprompt = (...args) => new Response$1().reprompt(...args), _class.shouldEndSession = (...args) => new Response$1().shouldEndSession(...args), _class.directives = (...args) => new Response$1().directives(...args), _class.build = params => Object.keys(params).reduce((response, action) => {
  const options = params[action];
  const text = typeof options === 'string' ? options : options;
  const type = typeof options === 'string' ? undefined : options.type;
  switch (action) {
    case 'ask':
      return response.ask(text, type);
    case 'say':
      return response.say(text, type);
    case 'reprompt':
      return response.reprompt(text, type);
    case 'card':
      return response.card(options);
    case 'attributes':
      return response.attributes(options);
    case 'shouldEndSession':
      return response.shouldEndSession(options);
    case 'directives':
      return response.directives(options);
  }
}, new Response$1()), _temp);
const outputSpeech = (text, type = alexaConstants.SpeechType.PlainText) => {
  if (type === alexaConstants.SpeechType.SSML || typeof text === 'object') {
    const speech = typeof text === 'object' ? ssmlJsx.renderToString(text) : text;
    return { outputSpeech: { type: alexaConstants.SpeechType.SSML, ssml: speech } };
  } else {
    return { outputSpeech: { type, text } };
  }
};

const { Directive, PlayBehavior, ClearBehavior } = alexaConstants.AudioPlayer;

var AudioPlayer$1 = {
  play(stream) {
    return {
      type: Directive.Play,
      playBehavior: PlayBehavior.ReplaceAll,
      audioItem: { stream }
    };
  },

  enqueue(stream, replaceQueue = false) {
    return {
      type: Directive.Play,
      playBehavior: replaceQueue ? PlayBehavior.ReplaceEnqueued : PlayBehavior.Enqueue,
      audioItem: { stream }
    };
  },

  stop() {
    return {
      type: Directive.Stop
    };
  },

  clearQueue(stopCurrent = false) {
    return {
      type: Directive.ClearQueue,
      clearBehavior: stopCurrent ? ClearBehavior.ClearAll : ClearBehavior.ClearEnqueued
    };
  }
};

// For commonjs compatibility
const ask = Response$1.ask;
const say = Response$1.say;
const card = Response$1.card;
const reprompt = Response$1.reprompt;
const shouldEndSession = Response$1.shouldEndSession;
const directives = Response$1.directives;
const build = Response$1.build;

exports.AudioPlayer = AudioPlayer$1;
exports.Response = Response$1;
exports['default'] = Response$1;
exports.ask = ask;
exports.say = say;
exports.card = card;
exports.reprompt = reprompt;
exports.shouldEndSession = shouldEndSession;
exports.directives = directives;
exports.build = build;
